<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"> 
  <title>Tetris — Mobile Friendly (Single File)</title>
  <style>
    :root{
      --bg:#0f1724; --panel:#0b1220; --accent:#7c3aed; --muted:#94a3b8; --glass: rgba(255,255,255,0.04);
    }
    html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; background:linear-gradient(180deg,#071133 0%, #071a2a 60%); color:#e6eef8}
    .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:20px}
    .board-wrap{display:grid;grid-template-columns:1fr 260px;gap:18px;align-items:start;width:100%;max-width:920px}
    .card{background:var(--panel);border-radius:14px;padding:14px;box-shadow:0 6px 30px rgba(2,6,23,0.6);backdrop-filter: blur(6px)}
    .title{display:flex;gap:12px;align-items:center;margin-bottom:8px}
    .logo{width:48px;height:48px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#06b6d4);display:flex;align-items:center;justify-content:center;font-weight:700}
    h1{font-size:18px;margin:0}
    .meta{color:var(--muted);font-size:13px}
    /* canvas area */
    .board-card{display:flex;flex-direction:column;align-items:center}
    #gameCanvas{background:linear-gradient(180deg,#081028,#06101b);border-radius:8px;touch-action:none}
    .controls{display:flex;gap:8px;margin-top:10px}
    .btn{background:var(--glass);border-radius:10px;padding:8px 10px;font-weight:600;border:1px solid rgba(255,255,255,0.03);color:var(--muted);min-width:72px;text-align:center}
    .hud{display:flex;flex-direction:column;gap:8px}
    .panel-small{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px}
    .row{display:flex;justify-content:space-between;align-items:center}
    .big{font-size:20px;font-weight:700}
    .small{font-size:12px;color:var(--muted)}
    .preview, .hold{width:100%;height:96px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:8px;display:grid;place-items:center}
    .footer{margin-top:10px;color:var(--muted);font-size:12px}
    /* mobile control overlay */
    .touch-ctls{display:none;position:relative}
    .touch-pad{position:relative;width:100%;height:84px;margin-top:10px;display:flex;gap:8px}
    .touch-pad button{flex:1;border-radius:12px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.02);color:var(--muted);font-weight:600}@media (max-width:760px){
  .board-wrap{grid-template-columns:1fr;}
  .touch-ctls{display:block}
  .card{padding:12px}
  .preview, .hold{height:72px}
}

  </style>
</head>
<body>
  <div class="wrap">
    <div class="board-wrap">
      <div class="card board-card">
        <div class="title">
          <div class="logo">T</div>
          <div>
            <h1>Tetris — Mobile Friendly</h1>
            <div class="meta">Swipe to move, tap to rotate, swipe down to drop. Works on desktop too.</div>
          </div>
        </div><canvas id="gameCanvas" width="300" height="600"></canvas>

    <div class="touch-ctls">
      <div class="touch-pad" id="touchPad" aria-hidden="true">
        <button id="leftBtn">◀︎</button>
        <button id="rotateBtn">⤾</button>
        <button id="rightBtn">▶︎</button>
        <button id="downBtn">▼</button>
      </div>
    </div>

    <div class="controls">
      <div class="btn" id="startBtn">Start</div>
      <div class="btn" id="pauseBtn">Pause</div>
      <div class="btn" id="resetBtn">Reset</div>
    </div>
    <div class="footer">Tip: open in full-screen on mobile for the best experience.</div>
  </div>

  <div class="card hud">
    <div class="panel-small row">
      <div>
        <div class="small">Score</div>
        <div class="big" id="score">0</div>
      </div>
      <div>
        <div class="small">Level</div>
        <div class="big" id="level">1</div>
      </div>
    </div>

    <div class="panel-small" style="margin-top:12px">
      <div class="small">Next</div>
      <div class="preview" id="nextPreview"></div>
    </div>

    <div class="panel-small" style="margin-top:12px">
      <div class="small">Hold</div>
      <div class="hold" id="holdPreview">—</div>
    </div>

    <div style="margin-top:12px" class="panel-small">
      <div class="small">How to play</div>
      <ul style="margin:6px 0 0 18px;color:var(--muted);font-size:13px">
        <li>Swipe left/right: move</li>
        <li>Tap: rotate</li>
        <li>Swipe down (fast): hard drop</li>
        <li>Buttons available for accessibility</li>
      </ul>
    </div>

    <div style="margin-top:12px" class="panel-small">
      <div class="small">Publish to GitHub Pages</div>
      <div style="color:var(--muted);font-size:13px;margin-top:6px">Save this file as <code>index.html</code>, push to a GitHub repo, then enable Pages on branch <code>main</code>.</div>
    </div>
  </div>
</div>

  </div><script>
// Tetris implementation (single-file, mobile touch friendly)
(() => {
  const COLS = 10, ROWS = 20;
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  let blockSize = 30; // will be computed

  function resizeCanvas(){
    const maxWidth = Math.min(window.innerWidth - 60, 420);
    blockSize = Math.floor(maxWidth / COLS);
    canvas.width = blockSize * COLS;
    canvas.height = blockSize * ROWS;
    // handle high DPI
    const dpr = window.devicePixelRatio || 1;
    canvas.style.width = canvas.width + 'px';
    canvas.style.height = canvas.height + 'px';
    canvas.width = Math.floor(canvas.width * dpr);
    canvas.height = Math.floor(canvas.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.imageSmoothingEnabled = false;
    draw();
  }
  window.addEventListener('resize', resizeCanvas);

  // colors for pieces
  const COLORS = {
    I:'#06b6d4', O:'#f59e0b', T:'#7c3aed', S:'#10b981', Z:'#ef4444', J:'#3b82f6', L:'#f97316'
  };

  // tetromino definitions (4 rotation states)
  const TETROMINOES = {
    I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    O: [[1,1],[1,1]],
    T: [[0,1,0],[1,1,1],[0,0,0]],
    S: [[0,1,1],[1,1,0],[0,0,0]],
    Z: [[1,1,0],[0,1,1],[0,0,0]],
    J: [[1,0,0],[1,1,1],[0,0,0]],
    L: [[0,0,1],[1,1,1],[0,0,0]]
  };

  function rotateMatrix(m){
    const N = m.length; const r = Array.from({length:N},_=>Array(N).fill(0));
    for(let y=0;y<N;y++)for(let x=0;x<N;x++)r[x][N-1-y] = m[y][x];
    return r;
  }

  function makeRotations(shape){
    const out = []; let m = shape;
    for(let i=0;i<4;i++){ out.push(m); m = rotateMatrix(m); }
    // remove duplicate rotations (for O and symmetric shapes)
    return out.filter((v,i,a)=>!a.slice(0,i).some(x=>JSON.stringify(x)===JSON.stringify(v)));
  }

  const PIECES = {};
  for(const k in TETROMINOES) PIECES[k] = makeRotations(TETROMINOES[k]);

  // game state
  let arena = createMatrix(COLS, ROWS);
  let current = null; let next = null; let hold = null; let canHold = true;
  let score = 0, level = 1, lines = 0; let dropInterval = 800; let lastDrop = 0; let running = false; let paused=false;

  function createMatrix(w,h){
    return Array.from({length:h},_=>Array(w).fill(0));
  }

  function newPiece(){
    const keys = Object.keys(PIECES);
    const k = keys[Math.floor(Math.random()*keys.length)];
    const rotations = PIECES[k];
    const rotIndex = 0;
    const shape = rotations[rotIndex];
    return {type:k, rotations, rotIndex, x: Math.floor((COLS - shape[0].length)/2), y: -shape.length, shape};
  }

  function spawn(){
    if(!next) next = newPiece();
    current = next; next = newPiece(); canHold = true;
    if(collide(arena, current)){
      // game over: reset
      running = false; paused = false; alert('Game Over! Score: ' + score); reset();
    }
  }

  function collide(arena, piece){
    const m = piece.shape; for(let y=0;y<m.length;y++)for(let x=0;x<m[y].length;x++){
      if(m[y][x]){
        const ay = piece.y + y; const ax = piece.x + x;
        if(ay<0) continue; // above top is allowed
        if(ay>=arena.length || ax<0 || ax>=arena[0].length) return true;
        if(arena[ay][ax]) return true;
      }
    }
    return false;
  }

  function merge(arena, piece){
    const m = piece.shape; for(let y=0;y<m.length;y++)for(let x=0;x<m[y].length;x++){
      if(m[y][x]){
        const ay = piece.y + y; const ax = piece.x + x;
        if(ay>=0) arena[ay][ax] = piece.type;
      }
    }
  }

  function rotate(piece){
    const rNew = (piece.rotIndex + 1) % piece.rotations.length;
    const newShape = piece.rotations[rNew];
    const oldX = piece.x; let kick = 0;
    // wall kick simple: try shift left/right
    for(let shift of [0,-1,1,-2,2]){
      piece.shape = newShape; piece.rotIndex = rNew; piece.x = oldX + shift;
      if(!collide(arena, piece)) return true;
    }
    // restore
    piece.rotIndex = (rNew + piece.rotations.length -1) % piece.rotations.length;
    piece.shape = piece.rotations[piece.rotIndex]; piece.x = oldX;
    return false;
  }

  function drop(){
    current.y++;
    if(collide(arena, current)){
      current.y--; merge(arena, current); sweepLines(); spawn();
    }
    lastDrop = performance.now();
    updateHUD();
  }

  function hardDrop(){
    while(!collide(arena, current)){
      current.y++;
    }
    current.y--; merge(arena, current); sweepLines(); spawn(); updateHUD();
  }

  function sweepLines(){
    let rowCount = 0;
    outer: for(let y=arena.length-1;y>=0;y--){
      for(let x=0;x<arena[y].length;x++) if(!arena[y][x]) continue outer;
      const row = arena.splice(y,1)[0].fill(0);
      arena.unshift(row); y++; rowCount++;
    }
    if(rowCount>0){
      const points = [0,40,100,300,1200];
      score += points[rowCount] * level;
      lines += rowCount; level = Math.floor(lines/10) + 1; dropInterval = Math.max(100, 800 - (level-1)*60);
    }
  }

  function move(dir){
    current.x += dir; if(collide(arena,current)) current.x -= dir; updateHUD();
  }

  function holdPiece(){
    if(!canHold) return; canHold = false; if(!hold){ hold = {type:current.type,rotations:current.rotations,rotIndex:0,shape:current.rotations[0]}; spawn(); } else {
      const tmp = hold; hold = {type:current.type,rotations:current.rotations,rotIndex:0,shape:current.rotations[0]}; current = {type:tmp.type, rotations:tmp.rotations, rotIndex:tmp.rotIndex, shape:tmp.shape, x: Math.floor((COLS - tmp.shape[0].length)/2), y: -tmp.shape.length};
    }
    updateHUD();
  }

  function updateHUD(){
    document.getElementById('score').textContent = score;
    document.getElementById('level').textContent = level;
    drawPreviews();
  }

  function draw(){
    // clear
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // background grid
    const w = canvas.width/ (window.devicePixelRatio || 1);
    const h = canvas.height/ (window.devicePixelRatio || 1);
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    ctx.fillRect(0,0,w,h);

    // draw arena blocks
    const cellW = w / COLS; const cellH = h / ROWS;
    ctx.lineWidth = 1;
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const val = arena[y][x]; if(val){ drawBlock(x,y, cellW, cellH, COLORS[val]); }
        // faint grid lines
        ctx.strokeStyle = 'rgba(255,255,255,0.02)';
        ctx.strokeRect(x*cellW + 0.5, y*cellH + 0.5, cellW, cellH);
      }
    }
    // draw current
    if(current){
      const m = current.shape;
      for(let y=0;y<m.length;y++) for(let x=0;x<m[y].length;x++){
        if(m[y][x]){
          const rx = current.x + x, ry = current.y + y;
          if(ry>=0) drawBlock(rx, ry, cellW, cellH, COLORS[current.type]);
        }
      }
    }
  }

  function drawBlock(x,y,cellW,cellH,color){
    const bw = Math.max(1, Math.floor(cellW*0.06));
    ctx.fillStyle = color; ctx.strokeStyle = shadeColor(color, -18);
    ctx.beginPath(); ctx.roundRect(x*cellW + bw/2, y*cellH + bw/2, cellW - bw, cellH - bw, 4); ctx.fill();
    ctx.lineWidth = 1; ctx.stroke();
  }

  // small helper: add roundRect to CanvasRenderingContext2D if missing
  if(!CanvasRenderingContext2D.prototype.roundRect) CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
    if(typeof r==='number') r = {tl:r,tr:r,br:r,bl:r};
    this.moveTo(x + r.tl, y);
    this.arcTo(x+w, y, x+w, y+h, r.tr);
    this.arcTo(x+w, y+h, x, y+h, r.br);
    this.arcTo(x, y+h, x, y, r.bl);
    this.arcTo(x, y, x+w, y, r.tl);
    this.closePath();
  }

  function shadeColor(hex, percent){
    const c = hex.replace('#',''); const num = parseInt(c,16);
    let r = (num>>16) + (percent/100)*255; let g = ((num>>8)&0x00FF) + (percent/100)*255; let b = (num&0x0000FF) + (percent/100)*255;
    r = Math.max(0,Math.min(255,Math.round(r))); g = Math.max(0,Math.min(255,Math.round(g))); b = Math.max(0,Math.min(255,Math.round(b)));
    return '#' + ( (1<<24) + (r<<16) + (g<<8) + b ).toString(16).slice(1);
  }

  // game loop
  function update(time){
    if(!running || paused){ lastDrop = time; requestAnimationFrame(update); draw(); return; }
    if(time - lastDrop > dropInterval){ current.y++; if(collide(arena,current)){ current.y--; merge(arena,current); sweepLines(); spawn(); } lastDrop = time; updateHUD(); }
    draw(); requestAnimationFrame(update);
  }

  function start(){ if(running) return; running = true; paused=false; if(!current) spawn(); lastDrop = performance.now(); requestAnimationFrame(update); }
  function pause(){ paused = !paused; }
  function reset(){ arena = createMatrix(COLS, ROWS); current = null; next = null; hold = null; score = 0; lines = 0; level =1; dropInterval = 800; updateHUD(); draw(); }

  // input handling for keyboard
  document.addEventListener('keydown', e=>{
    if(!running) return;
    if(e.key === 'ArrowLeft') move(-1);
    else if(e.key === 'ArrowRight') move(1);
    else if(e.key === 'ArrowUp') rotate(current);
    else if(e.key === 'ArrowDown') { drop(); }
    else if(e.key === ' ') hardDrop();
    else if(e.key.toLowerCase()==='c') holdPiece();
  });

  // on-screen buttons
  document.getElementById('startBtn').addEventListener('click', ()=>start());
  document.getElementById('pauseBtn').addEventListener('click', ()=>{ pause(); document.getElementById('pauseBtn').textContent = paused? 'Resume':'Pause'; });
  document.getElementById('resetBtn').addEventListener('click', ()=>{ reset(); });
  document.getElementById('leftBtn').addEventListener('click', ()=>move(-1));
  document.getElementById('rightBtn').addEventListener('click', ()=>move(1));
  document.getElementById('rotateBtn').addEventListener('click', ()=>{ rotate(current); updateHUD(); });
  document.getElementById('downBtn').addEventListener('click', ()=>{ drop(); });

  // touch gestures
  let touchStartX=0,touchStartY=0,touchStartTime=0, longPressTimer=null;
  const touchPad = document.getElementById('touchPad') || canvas;
  canvas.addEventListener('touchstart', handleTouchStart, {passive:false});
  canvas.addEventListener('touchmove', handleTouchMove, {passive:false});
  canvas.addEventListener('touchend', handleTouchEnd);

  function handleTouchStart(e){
    if(!running) return;
    e.preventDefault(); const t = e.changedTouches[0]; touchStartX = t.clientX; touchStartY = t.clientY; touchStartTime = performance.now();
    // long press => soft drop
    longPressTimer = setTimeout(()=>{ softDropStart(); }, 220);
  }
  function handleTouchMove(e){
    if(!running) return;
    e.preventDefault(); const t = e.changedTouches[0]; const dx = t.clientX - touchStartX; const dy = t.clientY - touchStartY;
    // small threshold
    const thresh = 24;
    if(Math.abs(dx) > thresh && Math.abs(dx) > Math.abs(dy)){
      // horizontal swipe
      if(dx > 0){ move(1); } else { move(-1); }
      touchStartX = t.clientX; // consume so repeated swipes move
      clearTimeout(longPressTimer);
    }
    if(Math.abs(dy) > thresh && Math.abs(dy) > Math.abs(dx)){
      if(dy > 0){ // downward
        // fast downward => hard drop
        if(Math.abs(dy) > 60){ hardDrop(); }
        else { drop(); }
        touchStartY = t.clientY;
        clearTimeout(longPressTimer);
      }
    }
  }
  function handleTouchEnd(e){
    if(!running) return;
    clearTimeout(longPressTimer); softDropStop();
    const t = e.changedTouches[0]; const dx = t.clientX - touchStartX; const dy = t.clientY - touchStartY; const dt = performance.now() - touchStartTime;
    const tapThresh = 14;
    if(Math.abs(dx) < tapThresh && Math.abs(dy) < tapThresh && dt < 300){ // tap
      rotate(current); updateHUD();
    }
  }

  // soft drop by holding (long press)
  let softInterval = null;
  function softDropStart(){
    if(softInterval) return; softInterval = setInterval(()=>{ drop(); }, 120);
  }
  function softDropStop(){ if(softInterval){ clearInterval(softInterval); softInterval = null; } }

  // preview render (simple small canvas inside div)
  function drawPreviews(){
    const nextEl = document.getElementById('nextPreview'); nextEl.innerHTML = '';
    const holdEl = document.getElementById('holdPreview'); holdEl.innerHTML = '';
    if(next){ drawMini(next, nextEl); }
    if(hold){ drawMini(hold, holdEl); }
  }
  function drawMini(piece, el){
    const mini = document.createElement('canvas'); mini.width=80; mini.height=80; mini.style.width='100%'; mini.style.height='100%';
    const mctx = mini.getContext('2d'); mctx.clearRect(0,0,mini.width,mini.height);
    const shape = piece.rotations[piece.rotIndex];
    const cell = Math.floor(mini.width / Math.max(shape.length, shape[0].length)) - 6;
    for(let y=0;y<shape.length;y++) for(let x=0;x<shape[y].length;x++){
      if(shape[y][x]){
        mctx.fillStyle = COLORS[piece.type]; mctx.fillRect(10 + x*cell, 10 + y*cell, cell-2, cell-2);
      }
    }
    el.appendChild(mini);
  }

  // init
  resizeCanvas(); reset();
  // start automatically on first tap/click for mobile-friendly gesture
  canvas.addEventListener('click', ()=>{ if(!running) start(); });

  // convenience: allow clicking the HUD next/hold to perform action
  document.getElementById('nextPreview').addEventListener('click', ()=>{});
  document.getElementById('holdPreview').addEventListener('click', ()=>{ holdPiece(); });

  // helper: small polyfill for requestAnimationFrame time
  requestAnimationFrame(update);

})();
</script></body>
</html>
